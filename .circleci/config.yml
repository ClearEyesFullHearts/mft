version: 2.1 # CircleCI version
orbs:
  browser-tools: circleci/browser-tools@1.4.1
  node: circleci/node@5.1.0
  aws-cli: circleci/aws-cli@3.1.5
jobs:
  build:
    machine:
      image: ubuntu-2004:current
      docker_layer_caching: true

    working_directory: ~/repo # Default working directory, where your project will be cloned

    steps:
      - checkout

      - browser-tools/install-browser-tools

      # - browser-tools/install-firefox

      # - browser-tools/install-chrome:
      #     replace-existing: true

      - node/install:
          node-version: "18.14.1"

      - run: cd ./docker/ci && KEY_AUTH_SIGN=${MFT_AUTH_KEY} CONFIG_RA_PASS=${MFT_CONF_RA_KEY} CONFIG_LM_PASS=${MFT_CONF_LM_KEY} CONFIG_MW_PASS=${MFT_CONF_MW_KEY} docker-compose up -d --build

      - run: sleep 40
      
      - run: mkdir -p ~/cucumber
      - run: docker logs -f config &> ~/cucumber/config.log &
      - run: docker logs -f log-manager &> ~/cucumber/log-manager.log &
      - run: docker logs -f mail-worker &> ~/cucumber/mail-worker.log &

      - run: cd ./test-api && npm install
      - run: cd ./test-api && KEY_AUTH_SIGN=${MFT_AUTH_KEY} npm run ci-test-api
      - run: cd ./test-api && npm run ci-report-api

      - run: cd ./test-front && npm install
      - run: cd ./test-front && npm run ci-test-chrome
      - run: cd ./test-front && npm run ci-report-chrome
      - run: cd ./test-front && npm run ci-test-firefox
      - run: cd ./test-front && npm run ci-report-firefox
      - store_test_results:
          path: ~/cucumber
      - store_artifacts:
          path: ~/cucumber
      - persist_to_workspace:
          root: .
          paths:
            - test-front

  push:
    machine:
      image: ubuntu-2004:current
    steps:
      - checkout
      - aws-cli/install
      - aws-cli/setup:
          aws-access-key-id: AWS_ACCESS_KEY_ID
          aws-secret-access-key: AWS_SECRET_ACCESS_KEY
          aws-region: AWS_DEFAULT_REGION
      - run:
          name: Install utils
          command: |
            apt-get update
            apt-get -y install jq
      - run:
          name: Generate full image name for new docker image
          command: |
            set -x
            FRONT_VERSION=$(cat front/package.json | jq -r '.version')
            FRONT_IMAGE_TAG=${FRONT_VERSION}.${CIRCLE_BUILD_NUM}
            REST_API_VERSION=$(cat apps/rest-api/package.json | jq -r '.version')
            REST_API_IMAGE_TAG=${REST_API_VERSION}.${CIRCLE_BUILD_NUM}
            CONFIG_HANDLER_VERSION=$(cat apps/rest-api/package.json | jq -r '.version')
            CONFIG_HANDLER_IMAGE_TAG=${CONFIG_HANDLER_VERSION}.${CIRCLE_BUILD_NUM}
            LOG_MANAGER_VERSION=$(cat apps/rest-api/package.json | jq -r '.version')
            LOG_MANAGER_IMAGE_TAG=${LOG_MANAGER_VERSION}.${CIRCLE_BUILD_NUM}
            MAIL_WORKER_VERSION=$(cat apps/rest-api/package.json | jq -r '.version')
            MAIL_WORKER_IMAGE_TAG=${MAIL_WORKER_VERSION}.${CIRCLE_BUILD_NUM}
            echo "$AWS_REGISTRY_URL:mft-front-$FRONT_IMAGE_TAG" > front_image_name
            echo "$AWS_REGISTRY_URL:mft-rest-api-$SERVER_IMAGE_TAG" > rest_api_image_name
            echo "$AWS_REGISTRY_URL:mft-config-handler-$CONFIG_HANDLER_IMAGE_TAG" > config_image_name
            echo "$AWS_REGISTRY_URL:mft-log-manager-$LOG_MANAGER_IMAGE_TAG" > log_image_name
            echo "$AWS_REGISTRY_URL:mft-mail-worker-$MAIL_WORKER_IMAGE_TAG" > mail_image_name
      - run:
          name: Authenticate with aws public ECR
          command: |
            aws ecr-public get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${AWS_REGISTRY_URL_SHORT}
      - run:
          name: Build image
          command: |
            FRONT_DOCKER_IMAGE_NAME=$(cat front_image_name)
            REST_API_DOCKER_IMAGE_NAME=$(cat rest_api_image_name)
            CONFIG_HANDLER_DOCKER_IMAGE_NAME=$(cat config_image_name)
            LOG_MANAGER_DOCKER_IMAGE_NAME=$(cat log_image_name)
            MAIL_WORKER_DOCKER_IMAGE_NAME=$(cat mail_image_name)
            docker build -t $FRONT_DOCKER_IMAGE_NAME --build-arg DOCKER_ENV=staging -f front/Dockerfile .
            docker build -t $REST_API_DOCKER_IMAGE_NAME -f docker/files/restapi.dockerfile .
            docker build -t $CONFIG_HANDLER_DOCKER_IMAGE_NAME -f docker/files/config.dockerfile .
            docker build -t $LOG_MANAGER_DOCKER_IMAGE_NAME -f docker/files/logmanager.dockerfile .
            docker build -t $MAIL_WORKER_DOCKER_IMAGE_NAME -f docker/files/mailworker.dockerfile .
      - run:
          name: Push image
          command: |
            FRONT_DOCKER_IMAGE_NAME=$(cat front_image_name)
            REST_API_DOCKER_IMAGE_NAME=$(cat rest_api_image_name)
            CONFIG_HANDLER_DOCKER_IMAGE_NAME=$(cat config_image_name)
            LOG_MANAGER_DOCKER_IMAGE_NAME=$(cat log_image_name)
            MAIL_WORKER_DOCKER_IMAGE_NAME=$(cat mail_image_name)
            docker push $FRONT_DOCKER_IMAGE_NAME
            docker push $REST_API_DOCKER_IMAGE_NAME
            docker push $CONFIG_HANDLER_DOCKER_IMAGE_NAME
            docker push $LOG_MANAGER_DOCKER_IMAGE_NAME
            docker push $MAIL_WORKER_DOCKER_IMAGE_NAME
      - persist_to_workspace:
          root: .
          paths:
            - front_image_name
            - rest_api_image_name
            - config_image_name
            - log_image_name
            - mail_image_name

workflows:
  version: 2
  build-push-deploy:
    jobs:
      - build
      - push:
          requires:
            - build
          filters:
            branches:
              only: set-aws-pipeline
